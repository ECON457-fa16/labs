---
title: "ECON457 lab01 R Basic"
author: "Jon"
date: "September 13, 2016"
output: html_document
---

Some basic information related to R lab01.

**First set working directory, by "Session -Set Working Directory" **

## Data type 

R has five basic or "atomic" classes of objects:

character

numeric (real numbers)

integer

complex

logical (True/False)


```{r}
x <- c(0.5, 0.6)       ## numeric
x <- c(TRUE, FALSE)    ## logical
x <- c(T, F)           ## logical
x <- c("a", "b", "c")  ## character
x <- c(1+0i, 2+4i)     ## complex
x <- 9:29              ## integer
```


## Data Structure


### Vector


The most basic type of R object is a vector. Empty vectors can be created with the vector() function. There is really only one rule about vectors in R, which is that A vector can only contain objects of the same class.

You can also use the vector() function to initialize vectors.



```{r}
x <- vector("numeric", length = 10) 
x
```


**A vector can only contain objects of the same class.**



### Matrix


```{r}
m <- matrix(nrow = 2, ncol = 3) 
m
```



Matrices can be created by column-binding or row-binding with the cbind() and rbind() functions.


```{r}
x <- 1:3
y <- 10:12
cbind(x, y)
```



```{r}
rbind(x, y) 
```




### Data Frames

Data frames are used to store tabular data in R. They are an important type of object in R and are used in a variety of statistical modeling applications. Hadley Wickham's package dplyr has an optimized set of functions designed to work efficiently with data frames.



```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F)) 
x
```

```{r}
nrow(x)

ncol(x)


names(x)
```



| Object     | Set column names | Set row names |
|------------|------------------|---------------|
| data frame | names()          | row.names()   |
| matrix     | colnames()       | rownames()    |


### Indexing


Indexing is used to specify the elements of an array. Indexing also allows you to get out certain bits of information from an array. To index into an array, type the name of the array, followed by the index of the element you want in brackets. Note that in R, indices start at 1. 

For a multidimensional array, index by [row,column]

To index an entire row or column, use a colon.



Below we index into the named y to get out the element in the second row, third column, 6.


```{r}
y <- c( 1,2,3, 4,5,6)
y <- matrix(y, nrow = 2, ncol = 3, byrow = T)
y[2,3]
```


Below, we index the entire first row of the array named y.


```{r}
y[1,]
```




Below, we index the entire second column of the array named y.



```{r}
y[,2]
```


## Load Data from Csv File

R works with many data formats. 

csv file is the most convenient.


### Load data locally 


Download file from [here][3]


```{r}
#pokemon <- read.csv("All_pokemon.csv")
```

Download data by R. 

```{r}

if (!file.exists("pokemon.csv")){
   download.file("https://github.com/Eighty20/eighty20.github.io/raw/master/_rmd/Post_data/All_pokemon.csv", destfile = "pokemon.csv",method="wininet")
}

```

#### Prefered Method

```{r}
library(readr) # prefered
pokemon <- read_csv("pokemon.csv")
```

```{r}
head(pokemon)
```


```{r}
str(pokemon)
```



#### Regular method. 

```{r}
pokemon <- read.csv("pokemon.csv")
```


```{r}
head(pokemon)
```


```{r}
str(pokemon)
```




###  directly from online repository.

#### Prefered Method

```{r}
library(readr) # prefered
pokemon <- read_csv("https://github.com/Eighty20/eighty20.github.io/raw/master/_rmd/Post_data/All_pokemon.csv")
```





More information about [pokeman][1] 

![Bulbasaur][2]


## Methods on Objects

A method is a procedure associated with an object. Below is a list of common methods used on arrays.

```{r}
length(y)
dim(y)
str(y)
attributes(y)
typeof(y)
head(y, 1)
tail(y,1)
```






## Mathematical Operations

Below is a list of common mathematical operations that you can perform on numerical types. 


x + y		performs addition


x - y		performs subtraction 


x * y		performs multiplication 


x / y		performs division

x ^ y		raises x to the yth power



x = y		assigns the variable named "x" to the value y


x == y	evaluates to a Boolean, true if x equals y, false otherwise

x != y 	evaluates to a Boolean, true if x does not equal y, false otherwise


x y		evaluates to a Boolean, true if x is greater than y, false otherwise


x < y		evaluates to a Boolean, true if x is less than y, false otherwise


x <= y	evaluates to a Boolean, true if x is less than or equal to y, false otherwise


x >= y	evaluates to a Boolean, true if x is greater than or equal to y, false otherwise

```{r}
9-4
9 / 4
```


```{r}
log(exp(10))
```



```{r}
sin(pi/2)
```




## Control Flow

### Condition  if/elseif/else 

Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a Boolean expression. You do not need all if/elseif/else statements. You can have conditional evaluations with just an if, or just an if/else.

The general structure of conditional evaluation is as follows.

After assigning values to x and y and running the code we obtain the following output.

```{r}
x =1
y=2
if (x<y){
  print(x)
}else{
  print(y)
}


```



### For Loops 

A for loop allows you to specify the number of iterations for the repeated execution of a code block. They are great when you know how many iterations you want to run. 

The general form of a for loop is shown below. The example shows a for loop that calculates the sum of the integers 1 through 10 and prints the final result. 

Note that to obtain a range of integers, we use the colon : symbol. 

```{r}
sum = 0
for(num in 1:10){
  sum = sum + num
}
print(sum)
```


A range of integers, we use the colon : symbol. 

```{r}
1:10
```


### A series of video of R tutorial. 

Each tutorial usually only is 2 minutes long.

http://www.twotorials.com/


## R for ECON

### R for ECON365/366

Matrix transposition

```{r}
M <- cbind(c(1,0,1),c(0,1,2),c(0,0,1))
t(M)

```

Matrix inversion

```{r}
solve(M)

solve(M)%*%M
```


Regression for Salary
```{r}

```


### R for ECON208

Solving a linear equation
```{r}
m=matrix(nrow=2,ncol=2,c(1,-.8,1,.2))

l=matrix(c(1.0+25.0/18,25.0/18.0))

(k=solve(m,l))

m%*%k          #checking the answer


```

Eigenvalues and eigenvectors

```{r}
eigen(m)
```



### R for ECON350/351

Symbolic calculations

```{r}
D(expression(x^n),"x")
D(expression(exp(a*x)),"x")
```


Compute derivatives of simple expressions, symbolically and algorithmically.


```{r}
trig.exp <- expression(sin(cos(x + y^2)))

( D.sc <- D(trig.exp, "x") )

all.equal(D(trig.exp[[1]], "x"), D.sc)
```



```{r}
## formula argument :
(MU1 <- deriv(~ x1^0.25*x2^0.25, "x1" )) ; 
(MU2<- deriv(~ x1^0.25*x2^0.25, "x1" ))

mode(MU1)
x1<- 2
x2 <- 2
eval(MU1)



```



#### Unconstrained optimization

```{r}
f <- function(x){(x[1] - 5)^2 + (x[2] - 6)^2}
initial_x <- c(10, 11)
x_optimal <- optim(initial_x, f, method="CG")
x_min <- x_optimal$par
x_min
```

## ECON457

#### Equality constraint optimization
#### Inequality constraint optimization
#### Linear Programming


Maximize expected return: f(x1, x2, x3) = x1*5% + x2*4% + x3*6%

Subjected to constraints:
    10% < x1, x2, x3 < 100%
    x1 + x2 + x3 = 1
    x3 < x1 + x2
    x1 < 2 * x2

```{r}
#install.packages("lpSolve")
#install.packages("lpSolveAPI")
library(lpSolve)
library(lpSolveAPI)
# Set the number of vars
model <- make.lp(0, 3)
# Define the object function: for Minimize, use -ve
set.objfn(model, c(-0.05, -0.04, -0.06))
# Add the constraints
add.constraint(model, c(1, 1, 1), "=", 1)
add.constraint(model, c(1, 1, -1), ">", 0)
add.constraint(model, c(1, -2, 0), "<", 0)
# Set the upper and lower bounds
set.bounds(model, lower=c(0.1, 0.1, 0.1), upper=c(1, 1, 1))
# Compute the optimized model
solve(model)

# Get the value of the optimized parameters
get.variables(model)

# Get the value of the objective function
get.objective(model)

# Get the value of the constraint
get.constraints(model)
```

#### Quadratic Programming


To formulate the problem:

Variable: x1 = % investment in A, x2 = % in B, x3 = % in C

Minimize variance: xTâˆ‘x

Subjected to constraint:
x1 + x2 + x3 == 1
X1*5% + x2*4% + x3*6% >= 5.2%
0% < x1, x2, x3 < 100%

```{r}
#install.packages("quadprog")
library(quadprog)
mu_return_vector <- c(0.05, 0.04, 0.06) 
sigma <- matrix(c(0.01, 0.002, 0.005, 
                   0.002, 0.008, 0.006, 
                   0.005, 0.006, 0.012), 
                  nrow=3, ncol=3)
D.Matrix <- 2*sigma
d.Vector <- rep(0, 3)
A.Equality <- matrix(c(1,1,1), ncol=1)
A.Matrix <- cbind(A.Equality, mu_return_vector, 
                    diag(3))
b.Vector <- c(1, 0.052, rep(0, 3))
out <- solve.QP(Dmat=D.Matrix, dvec=d.Vector, 
                  Amat=A.Matrix, bvec=b.Vector, 
                  meq=1)
out$solution

out$value

```


[source][4]

### Ryacas: Symbolic calculation

only works for R 3.3.2

```{r}
# options(repos = c(CRAN = "http://cran.rstudio.com"))
# install.packages('Ryacas')
# library(Ryacas)
# yacasInstall()
```



### R for ECON435/468

http://www.quantmod.com/
https://www.youtube.com/watch?v=61_F2fcvrsw

```{r}
install.packages("quantmod")
library(quantmod)
getSymbols(c("AMZN"))
barChart(AMZN,theme='white.mono',bar.type='hlc')

```



```{r}
getSymbols(c("^GSPC"))
chartSeries(GSPC, subset='last 3 months')
addBBands(n = 20, sd = 2, ma = "SMA", draw = 'bands', on = -1)
```

See what packages we used.

```{r}
sessionInfo()
```


[1]:http://www.levelbased.com/guides/pokemon-go/pokemon/?q=
[2]: http://www.levelbased.com/static/images/guides/pokemon-go/1/medium/bulbasaur.png "Bulbasaur"
[3]: https://github.com/Eighty20/eighty20.github.io/raw/master/_rmd/Post_data/All_pokemon.csv "Pokeman.csv" 
[4]: http://horicky.blogspot.ca/2013/01/optimization-in-r.html