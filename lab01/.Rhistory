x <- c(0.5, 0.6);typeof(x)       ## numeric
x <- c(TRUE, FALSE) ;typeof(x)    ## logical
x <- c(T, F)   ;typeof(x)         ## logical
x <- c("a", "b", "c");typeof(x)   ## character
x <- c(1+0i, 2+4i)  ;typeof(x)    ## complex
x <- 9:29   ;typeof(x)            ## integer
x <- c()
seq(9:29)
9:29
seq(9,29, by=1)
seq(9,29, by=2)
x <- 1:3
y <- 10:12
cbind(x, y)
rbind(x, y)
class(x$foo)
x$foo
str(x)
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
x
str(x)
x = seq(0, pi, 0.1)
y = sin(x)
x = seq(0, pi, pi/180)
y = sin(x)
plot(x,y)
x = seq(0, 2*pi, 2*pi/180)
y = sin(x)
plot(x,y)
?plot
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
points(x=pi, y=0, cex =2, col ="dark red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
abline(h=0)
abline(v=pi)
points(x=pi, y=0, cex =2, col ="dark red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
abline(h=0)
bookdown:::mathquill()
addinexamples:::subsetAddin()
## Setup up coordinate system (with x == y aspect ratio):
plot(c(-2,3), c(-1,5), type = "n", xlab = "x", ylab = "y", asp = 1)
## the x- and y-axis, and an integer grid
abline(h = 0, v = 0, col = "gray60")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.1, y = 0.3, labels = "Sin", col = "Red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.2, y = 0.3, labels = "Sin", col = "Red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.2, y = 0.3, labels = "Here", col = "Red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.3, y = 0.3, labels = "Here", col = "Red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.3, y = 0.2, labels = "Here", col = "Red")
plot(x,y, type = "l", col="blue", lwd="4",
main="sin", xlab = "x", ylab = "y")
## the x- and y-axis, and an integer grid
abline(h = 0, v = pi, col = "gray60")
points(x=pi, y=0, cex =2, col ="dark red")
text(x=pi+0.3, y = 0.1, labels = "Here", col = "Red")
pokemon <- read.csv("All_pokemon.csv")
head(pokemon)
str(pokemon)
hp <- pokemon$HP
head(hp)
type1 <- pokemon$Type.I
head(type1)
type2 <- pokemon$Type.II
head(type2)
table(type2)
plot(pokemon$HP, pokemon$Atk)
plot(pokemon$HP, pokemon$Atk, col= "green")
View(pokemon)
Dragon <-  pokemon[type2 == "Dragon"]
Dragon <-  pokemon[Type.II == "Dragon"]
Dragon <-  pokemon[pokemon$Type.II == "Dragon"]
Dragon <-  pokemon[pokemon$Type.II == "Dragon"]
Dragon <-  pokemon[pokemon$Type.I == "Dragon"]
table(pokemon$Type.I)
pokemon$Type.I
type2 <- pokemon["Type.II"]
head(type2)
type2 <- pokemon[,"Type.II"]
head(type2)
pokemon$Type.I
Dragon <-  pokemon[, pokemon$Type.I == "Dragon"]
pokemon$Type.I == "Dragon"
Dragon <-  pokemon[ pokemon$Type.I == "Dragon", ]
head(Dragon)
pokemon[ pokemon$HP >300, ]
pokemon[ pokemon$HP >100, ]
pokemon[ pokemon$HP >150, ]
type2 <- pokemon[,"Type.II"]
write.csv(Dragon, file="Dragon.csv")
write.csv(Dragon,file="Dragon.csv",
file="cleaned-data/gapminder-aus.csv",
quote=FALSE, row.names=FALSE)
write.csv(Dragon,file="Dragon.csv",
quote=FALSE, row.names=FALSE)
write.csv(Dragon, file="Dragon.csv")
z <- 1
z <- 1
while(z > 0.1){
z <- runif(1)
print(z)
}
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
my_sum <- function(a, b) {
the_sum <- a + b
return(the_sum)
}
my_sum(3, 5)
pokemon <- read.csv("All_pokemon.csv")
head(pokemon)
install.packages("rmarkdown")
install.packages(c("foreign", "lattice", "Matrix", "mgcv", "survival"))
install.packages("statsr")
library(devtools)
install.packages("httpuv")
install_github("StatsWithR/statsr")
library(devtools)
install.packages("devtools")
library(devtools)
install.packages("httpuv")
install_github("StatsWithR/statsr")
install.packages("curl")
install.packages("curl")
install_github("StatsWithR/statsr")
install.packages("swirl", repos="http://cran.rstudio.com/", dependencies=TRUE)
install_github("StatsWithR/statsr")
install.packages("curl", repos="http://cran.rstudio.com/", dependencies=TRUE)
install_github("StatsWithR/statsr")
library(devtools)
install_github("StatsWithR/statsr")
install.packages("gtable")
install_github("StatsWithR/statsr")
install.packages("scales")
install_github("StatsWithR/statsr")
install.packages("xtable")
install_github("StatsWithR/statsr")
options(repos = c(CRAN = "http://cran.rstudio.com"))
install.packages('Ryacas')
library(Ryacas)
install.packages("quantmod")
library(foreign)
wage1 <- read.dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
# OLS regression:
ols.model <-  lm(log(wage) ~ educ+exper+tenure, data=wage1)
summary(ols.model)
confint(ols.model)
coef(ols.model)
M <- cbind(c(1,0,1),c(0,1,2),c(0,0,1))
t(M)
solve(M)
solve(M)%*%M
m=matrix(nrow=2,ncol=2,c(1,-.8,1,.2))
l=matrix(c(1.0+25.0/18,25.0/18.0))
(k=solve(m,l))
m%*%k          #checking the answer
eigen(m)
D(expression(x^n),"x")
D(expression(exp(a*x)),"x")
trig.exp <- expression(sin(cos(x + y^2)))
( D.sc <- D(trig.exp, "x") )
all.equal(D(trig.exp[[1]], "x"), D.sc)
(MU1 <- deriv(~ x1^0.25*x2^0.25, "x1" )) ;
(MU2<- deriv(~ x1^0.25*x2^0.25, "x1" ))
mode(MU1)
x1<- 2
x2 <- 2
eval(MU1)
install.packages("quadprog")
install.packages("lpSolve")
install.packages("lpSolveAPI")
library(lpSolve)
library(lpSolveAPI)
model <- make.lp(0, 3)
set.objfn(model, c(-0.05, -0.04, -0.06))
add.constraint(model, c(1, 1, 1), "=", 1)
add.constraint(model, c(1, 1, -1), ">", 0)
add.constraint(model, c(1, -2, 0), "<", 0)
set.bounds(model, lower=c(0.1, 0.1, 0.1), upper=c(1, 1, 1))
solve(model)
get.variables(model)
get.objective(model)
get.constraints(model)
library(quadprog)
mu_return_vector <- c(0.05, 0.04, 0.06)
sigma <- matrix(c(0.01, 0.002, 0.005,
0.002, 0.008, 0.006,
0.005, 0.006, 0.012),
nrow=3, ncol=3)
D.Matrix <- 2*sigma
d.Vector <- rep(0, 3)
A.Equality <- matrix(c(1,1,1), ncol=1)
A.Matrix <- cbind(A.Equality, mu_return_vector,
diag(3))
b.Vector <- c(1, 0.052, rep(0, 3))
out <- solve.QP(Dmat=D.Matrix, dvec=d.Vector,
Amat=A.Matrix, bvec=b.Vector,
meq=1)
out$solution
out$value
library(rSymPy)
install.packages("rSymPy")
library(Ryacas)
package?Ryacas
demo("Ryacas")
demo("Ryacas-Sym")
print(yacas(expression(integrate(1/x, x))))
print(yacas("Integrate(x)1/x"))
x <- Sym("x"); Integrate(1/x, x)
acos(Sym("1/2"))
library(rSymPy)
install.packages("rJava")
library(rSymPy)
yacasInstall()
library(Ryacas)
yacasInstall()
my_func <- function(x) {
return(x/(x^2 + 3))
}
my_deriv <- yacas(deriv(my_func(x), x))
print(yacas(expression(integrate(1/x, x))))
print(yacas("Integrate(x) 1/x"))
x <- Sym("x"); Integrate(1/x, x)
a <- c(3,6,9,12)
a <- vector(3,6,9,12)
a <- vector(3,6)
A <- matrix(c(1,2,3, 4,5,6, 7,8 ,9), nrow = 3, ncol = 3, byrow = T)
A
for (i in 1:10){
print(i)
}
plot(pokemon$HP,  pokemon$Atk , type = "l", col="green", lwd="4",
main="Pokemon", xlab = "HP", ylab = "Atk")
plot(pokemon$HP,  pokemon$Atk , type = "p", col="green", lwd="4",
main="Pokemon", xlab = "HP", ylab = "Atk")
x <- vector("numeric", length = 10)
x
```
```{r}
y <-  c(1,2,3,4,5,6,7,8,9)
y
x <- 1:10
x
y <- seq(9,29, by=2)
y
a <- seq(3,12,3)
a
